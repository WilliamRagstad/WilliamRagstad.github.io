+++
title = 'Profunctor Optics in Rust'
date = 2025-12-04T21:00:59+02:00
series = ["Understanding"]
series_order = 4
tags = ["rust", "optics", "functional programming"]
categories = ["computer science", "programming languages", "category theory"]
showHero = true
draft = true
+++
{{< katex >}}

## Introduction

For some time now, I've had an interest in learning more about category theory and its applications in functional programming.
Recently, I came across the concept of **profunctor optics**, which I found out to be super powerful abstractions for **manipulating data structures in a composable way**.
I'll admit that understanding profunctor optics was quite the challenge for me, especially when trying to grasp the underlying category theory concepts behind them and decode the dense academic notation used to explain them.
So that's why I decided to write this post, to share my journey of understanding profunctor optics, why they are useful and how to implement them in Rust.

## Background

In order to understand the following concepts, we first need to cover some basic notation, terminology, and fundamental ideas.

### What are Optics?

### What is a Profunctor?

## Profunctor Optics

---
{{< support >}}

<!----------------------------------------------------------------->
